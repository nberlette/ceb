<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>&lt;ceb/&gt; ~ Custom Element Builder</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The book presents the usage of the ceb library.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Custom Element Builder</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">2.</strong> Packages</a></li><li class="chapter-item expanded "><a href="inversion/index.html"><strong aria-hidden="true">3.</strong> Inversion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="inversion/hexagonal_architecture.html"><strong aria-hidden="true">3.1.</strong> Hexagonal Architecture</a></li><li class="chapter-item expanded "><a href="inversion/ioc.html"><strong aria-hidden="true">3.2.</strong> IOC implementation</a></li><li class="chapter-item expanded "><a href="inversion/hexagonal_testing.html"><strong aria-hidden="true">3.3.</strong> Hexagonal Testing</a></li></ol></li><li class="chapter-item expanded "><a href="messaging/index.html"><strong aria-hidden="true">4.</strong> Messaging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="messaging/concepts.html"><strong aria-hidden="true">4.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="messaging/messages.html"><strong aria-hidden="true">4.2.</strong> Messages</a></li><li class="chapter-item expanded "><a href="messaging/gateway.html"><strong aria-hidden="true">4.3.</strong> Gateway</a></li><li class="chapter-item expanded "><a href="messaging/inversion.html"><strong aria-hidden="true">4.4.</strong> Inversion integration</a></li><li class="chapter-item expanded "><a href="messaging/implementation.html"><strong aria-hidden="true">4.5.</strong> Reference Implementation</a></li><li class="chapter-item expanded "><a href="messaging/adapters.html"><strong aria-hidden="true">4.6.</strong> Adapters</a></li></ol></li><li class="chapter-item expanded "><a href="elements/index.html"><strong aria-hidden="true">5.</strong> Elements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="elements/ElementBuilder.html"><strong aria-hidden="true">5.1.</strong> ElementBuilder</a></li><li class="chapter-item expanded "><a href="elements/AttributeBuilder.html"><strong aria-hidden="true">5.2.</strong> AttributeBuilder</a></li><li class="chapter-item expanded "><a href="elements/FieldBuilder.html"><strong aria-hidden="true">5.3.</strong> FieldBuilder</a></li><li class="chapter-item expanded "><a href="elements/OnBuilder.html"><strong aria-hidden="true">5.4.</strong> OnBuilder</a></li><li class="chapter-item expanded "><a href="elements/ContentBuilder.html"><strong aria-hidden="true">5.5.</strong> ContentBuilder</a></li><li class="chapter-item expanded "><a href="elements/TemplateBuilder.html"><strong aria-hidden="true">5.6.</strong> TemplateBuilder</a></li><li class="chapter-item expanded "><a href="elements/ReferenceBuilder.html"><strong aria-hidden="true">5.7.</strong> ReferenceBuilder</a></li><li class="chapter-item expanded "><a href="elements/AttributePropagationBuilder.html"><strong aria-hidden="true">5.8.</strong> AttributePropagationBuilder</a></li><li class="chapter-item expanded "><a href="elements/PropertyDelegationBuilder.html"><strong aria-hidden="true">5.9.</strong> PropertyDelegationBuilder</a></li></ol></li><li class="chapter-item expanded "><a href="templating/index.html"><strong aria-hidden="true">6.</strong> Templating</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="templating/grey_dom.html"><strong aria-hidden="true">6.1.</strong> Grey DOM</a></li><li class="chapter-item expanded "><a href="templating/literal.html"><strong aria-hidden="true">6.2.</strong> Template literal</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">7.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/todomvc/index.html"><strong aria-hidden="true">7.1.</strong> TodoMVC</a></li><li class="chapter-item expanded "><a href="examples/ex-greeting.html"><strong aria-hidden="true">7.2.</strong> ex-greeting</a></li></ol></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">8.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">&lt;ceb/&gt; ~ Custom Element Builder</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tmorin/ceb/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ceb--custom-element-builder"><a class="header" href="#ceb--custom-element-builder">&lt;ceb/&gt; ~ Custom Element Builder</a></h1>
<p><code>&lt;ceb/&gt;</code> was initially a library dedicated for the authoring of <a href="https://www.w3.org/TR/2018/WD-custom-elements-20180216/">Custom Elements (v0)</a> then <a href="https://html.spec.whatwg.org/multipage/custom-elements.html">Custom Elements (v1)</a>.
However, the library is now providing building blocks going beyond the topic of composable UI elements.
It's about fundamental design principles, messaging, functional rendering and obviously composition of UI elements ;).</p>
<p><code>&lt;ceb/&gt;</code> is released under the <a href="http://opensource.org/licenses/MIT">MIT license</a>.</p>
<p>The source code is available on GitHub: <a href="https://github.com/tmorin/ceb">github.com/tmorin/ceb</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<p>The library is composed of many packages published on <a href="https://www.npmjs.com">npmjs.com</a>.
All packages are compliant <a href="https://flaviocopes.com/commonjs">CommonJs</a> and <a href="https://flaviocopes.com/es-modules">ES Module</a>.
That means, they can be directly used in almost all JavaScript runtimes.</p>
<p>Inversion Of Control:</p>
<ul>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-inversion-core">@tmorin/ceb-inversion-core</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-inversion-builder">@tmorin/ceb-inversion-builder</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-inversion-testing-core">@tmorin/ceb-inversion-testing-core</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-inversion-testing-jest">@tmorin/ceb-inversion-testing-jest</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-inversion-testing-mocha">@tmorin/ceb-inversion-testing-mocha</a></li>
</ul>
<p>Event/Message Architecture:</p>
<ul>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-core">@tmorin/ceb-messaging-core</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-inversion">@tmorin/ceb-messaging-inversion</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-simple">@tmorin/ceb-messaging-simple</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-simple-builder">@tmorin/ceb-messaging-simple-builder</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-testing">@tmorin/ceb-messaging-testing</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-builder-core">@tmorin/ceb-messaging-builder-core</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-builder-inversion">@tmorin/ceb-messaging-builder-inversion</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-adapter-dom">@tmorin/ceb-messaging-adapter-dom</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-adapter-electron">@tmorin/ceb-messaging-adapter-electron</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-adapter-purify">@tmorin/ceb-messaging-adapter-purify</a></li>
</ul>
<p>Custom Element Authoring:</p>
<ul>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-elements-core">@tmorin/ceb-elements-core</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-elements-builders">@tmorin/ceb-elements-builders</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-elements-testing">@tmorin/ceb-elements-testing</a></li>
</ul>
<p>Templating:</p>
<ul>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-templating-engine">@tmorin/ceb-templating-engine</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-templating-parser">@tmorin/ceb-templating-parser</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-templating-literal">@tmorin/ceb-templating-literal</a></li>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-templating-builder">@tmorin/ceb-templating-builder</a></li>
</ul>
<p>Support:</p>
<ul>
<li><a href="https://www.npmjs.com/package/@tmorin/ceb-utilities">@tmorin/ceb-utilities</a></li>
</ul>
<h2 id="universal-module-definition"><a class="header" href="#universal-module-definition">Universal Module Definition</a></h2>
<p>The bundle package <a href="https://www.npmjs.com/package/@tmorin/ceb-bundle-web">@tmorin/ceb-bundle-web</a> is also available as a <code>UMD</code> module from <a href="https://cdn.skypack.dev">cdn.skypack.dev</a>.</p>
<pre><code class="language-html">&lt;!-- the optimized Universal Module Definition --&gt;
&lt;script src=&quot;https://cdn.skypack.dev/@tmorin/ceb-bundle-web/dist/umd/ceb.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- the not optimized Universal Module Definition --&gt;
&lt;script src=&quot;https://cdn.skypack.dev/@tmorin/ceb-bundle-web/dist/umd/ceb-bundle-web.js&quot;&gt;&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inversion"><a class="header" href="#inversion">Inversion</a></h1>
<p><code>&lt;ceb/&gt;</code> provides a built-in implementation of the Inversion Of Control principle.
Its purpose is to emphasize loose coupling between programing artifacts like classes, modules ...
But also to improve the modularity and extensibility of the overall software architecture like the Hexagonal Architecture.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hexagonal-architecture"><a class="header" href="#hexagonal-architecture">Hexagonal Architecture</a></h1>
<p>Despite both following facts, the IoC container can be applied to other architecture styles and the Hexagonal Architecture can be implemented without IoC, at the end, IoC and Hexagonal Architecture just work well together :).</p>
<p>This architecture helps to refine a model to separate the functional to the technical.
The technical concern is pushed to the boundary of the <em>model</em> within contracts (i.e. interfaces), identified as <em>ports</em>.
The contacts are implemented within the <em>infrastructure</em> by <em>adapters</em></p>
<p><img src="inversion/hexagonal-port_adapter.png" alt="Port and adapter" /></p>
<p>Obviously, a <em>port</em> can be satisfied by many <em>adapters</em>.
Therefore, it becomes easy to configure a <em>setup</em> by execution contexts: development, integration testing, functional testing, production ...</p>
<p><img src="inversion/hexagonal-port_adapters.png" alt="One port, many adapters" /></p>
<p>The relationship between two <em>models</em> can be handled with a regular Facade.</p>
<p><img src="inversion/hexagonal-model_relationships.png" alt="The model to model relationship" /></p>
<p>However, the relationship can be handled using the port/adapter approach.
The introduction of a component which expose only the API of a model leads to definition of contextual adapters.
For instance, the component API can be satisfied by an adapter dedicated for testing purpose which is just a <em>mock</em> of the core implementation.</p>
<p><img src="inversion/hexagonal-model_modularity.png" alt="Modularity of the model's Facade" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ioc-implementation"><a class="header" href="#ioc-implementation">IoC implementation</a></h1>
<blockquote>
<p>The IOC implementation is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-inversion-core">@tmorin/ceb-inversion-core</a>.</p>
</blockquote>
<p>This IoC implementation relies on three main concepts.
The first one is the <em>registry</em>.
Its purpose is to provide services to register and resolve items.
The second concept, the <em>module</em>, interacts with the registry in order to configure items to register.
Finally, the last one, the <em>container</em>, manages the lifecycle of the modules and, therefore, the lifecycle of the registry's items too.</p>
<p><img src="inversion/ioc-container-overview.png" alt="The Container, the Registry and the Modules" /></p>
<h2 id="the-container"><a class="header" href="#the-container">The Container</a></h2>
<p><img src="inversion/ioc-container-lifecycle.png" alt="The Container lifecycle" /></p>
<p>A Container is created using the <code>ContainerBuilder</code>, and especially its <code>build()</code> method.
Once built, the Container can be initialized, so that Modules and Components will be configured.
When a Container becomes useless, it has to be disposed, so that Modules and Components will be disposed too.
Once disposed, a container cannot be used anymore.</p>
<pre><code class="language-typescript">import { ContainerBuilder } from &quot;@tmorin/ceb-inversion-core&quot;

ContainerBuilder.get()
.build() // from `void` to `Built`
.initialize() // from `Built` to `Alive`
.then((container) =&gt; {
  return container.dispose() // from `Alive` to `Disposed`
})
</code></pre>
<h2 id="the-registry"><a class="header" href="#the-registry">The Registry</a></h2>
<p>The Registry handles only two kinds of registration modes: <em>by value</em> and <em>by factory</em>.</p>
<p>With the <em>by value</em> mode, the value must exist at the time of the registration, and the registry will always resolve it.</p>
<pre><code class="language-typescript">import { DefaultRegistry } from &quot;@tmorin/ceb-inversion-core&quot;

// create a fresh registry
const registry = new DefaultRegistry()

// register a Value
registry.registerValue(&quot;key&quot;, &quot;the value&quot;)

// resolve the entry
const a = registry.resolve(&quot;key&quot;)

// resolve again the entry
const b = registry.resolve(&quot;key&quot;)

// assert instances are the same
console.assert(a === b)
</code></pre>
<p>However, with the <em>by factory</em> mode, the value is created at the resolution time.
Moreover, its creation can be based on entries available in the registry.
By default, the factory is invoked for each resolution.</p>
<pre><code class="language-typescript">import { DefaultRegistry } from &quot;@tmorin/ceb-inversion-core&quot;

// create a fresh registry
const registry = new DefaultRegistry()

// register a Factory
registry.registerFactory(&quot;key&quot;, () =&gt; ({ k: &quot;v&quot; }))

// resolve the entry
const a = registry.resolve(&quot;key&quot;)

// resolve again the entry
const b = registry.resolve(&quot;key&quot;)

// assert instances are not the same
console.assert(a !== b)
</code></pre>
<p>The option <code>singleton</code> prevents this invocation of the factory at each resolution.
That means the value is created only once, at its first resolution.</p>
<pre><code class="language-typescript">import { DefaultRegistry } from &quot;@tmorin/ceb-inversion-core&quot;

// create a fresh registry
const registry = new DefaultRegistry()

// register a Factory acting as a singleton
registry.registerFactory(&quot;key&quot;, () =&gt; ({ k: &quot;v&quot; }), { singleton: true })

// resolve the entry
const a = registry.resolve(&quot;key&quot;)

// resolve again the entry
const b = registry.resolve(&quot;key&quot;)

// assert instances are the same
console.assert(a === b)
</code></pre>
<h2 id="the-modules"><a class="header" href="#the-modules">The Modules</a></h2>
<p><img src="inversion/ioc-container-module.png" alt="The modules hierarchy" /></p>
<p>A Module helps to bundle entry registrations to the registry.
It's an implementation of the interface <code>Module</code>.
However, a convenient abstracted implementation, <code>AbstractModule</code>, handles already the boilerplate stuff.</p>
<pre><code class="language-typescript">import { AbstractModule } from &quot;@tmorin/ceb-inversion-core&quot;

export class WorldModule extends AbstractModule {
async configure(): Promise&lt;void&gt; {
  // register a name
  this.registry.registerValue(&quot;name&quot;, &quot;World&quot;)
}
}

export class GreetingModule extends AbstractModule {
async configure(): Promise&lt;void&gt; {
  // register a factory
  this.registry.registerFactory(
    &quot;greeting&quot;,
    (registry) =&gt; `Hello, ${registry.resolve(&quot;name&quot;)}!`
  )
}
}
</code></pre>
<p>The modules are used during the creation of a container and must be provided to the ContainerBuilder.</p>
<pre><code class="language-typescript">import { ContainerBuilder } from &quot;@tmorin/ceb-inversion-core&quot;
import { GreetingModule, WorldModule } from &quot;./ioc-container-module-class&quot;

ContainerBuilder.get()
.module(new GreetingModule())
.module(new WorldModule())
.build()
.initialize()
.then((container) =&gt; {
  // resolve the greeting entry
  const greeting = container.registry.resolve(&quot;greeting&quot;)
  // assert the greeting text match the expected one
  console.assert(greeting === &quot;Hello, World!&quot;)
  // release the stateful stuff
  return container.dispose()
})
.catch((e) =&gt; console.error(e))
</code></pre>
<p>Sometime, the class usage can be a bit too much.
Therefore, an inline way to available using <code>OnlyConfigureModule.create(...)</code>.</p>
<pre><code class="language-typescript">import {
ContainerBuilder,
OnlyConfigureModule,
} from &quot;@tmorin/ceb-inversion-core&quot;

ContainerBuilder.get()
.module(
  OnlyConfigureModule.create(async function () {
    // register a name
    this.registry.registerValue(&quot;name&quot;, &quot;John Doe&quot;)
    // register a factory
    this.registry.registerFactory(
      &quot;greeting&quot;,
      (registry) =&gt; `Hello, ${registry.resolve(&quot;name&quot;)}!`
    )
  })
)
.build()
.initialize()
.then((container) =&gt; {
  // resolve the greeting entry
  const greeting = container.registry.resolve(&quot;greeting&quot;)
  // assert the greeting text match the expected one
  console.assert(greeting === &quot;Hello, John Doe!&quot;)
  // release the stateful stuff
  return container.dispose()
})
.catch((e) =&gt; console.error(e))
</code></pre>
<h2 id="the-components"><a class="header" href="#the-components">The Components</a></h2>
<p><img src="inversion/ioc-container-component.png" alt="The Component" /></p>
<p>Components follow the lifecycle of Modules, i.e. <em>configure</em> then <em>dispose</em>.
To be discovered and managed by the Container, they must be registered with the <code>ComponentSymbol</code> Registry Key.</p>
<p>Components are the right places to implement Process Manager or other <em>reactive</em> programing artifacts.</p>
<pre><code class="language-typescript">import { Component } from &quot;@tmorin/ceb-inversion-core&quot;

// define a component
export class MyModule extends Component {
async configure(): Promise&lt;void&gt; {
  // execute things when container starts
}

async dispose(): Promise&lt;void&gt; {
  // execute things when container stops
}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hexagonal-testing"><a class="header" href="#hexagonal-testing">Hexagonal testing</a></h1>
<blockquote>
<p>The testing model is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-inversion-testing-core">@tmorin/ceb-inversion-testing-core</a>.</p>
</blockquote>
<p>The isolation, provided by the Hexagonal Architecture, makes the testing of models easier.
However, it leads to an annoying side effect: some tests, especially the functional ones, are duplicated among the adapters.</p>
<p><code>&lt;ceb/&gt;</code> provides a testing library to prevent test duplication.
The purpose is to define tests in the <em>model</em> which have to be executed in the <em>adapters</em>.
So that, an <em>adapter</em> can validate the <em>port</em> implementation satisfy the <em>model</em>.
The library leverages on the IoC container to let the <em>adapter</em> binds its implementation to the <em>port</em>.</p>
<p><img src="inversion/hexagonal_testing-model.png" alt="The testing model" /></p>
<p>From the <em>model</em> point of view, i.e. the supplier, the suites are created using the TestSuiteBuilder and the scenarios with the TestScenarioBuilder.</p>
<pre><code class="language-typescript">import { assert } from &quot;chai&quot;
import { OnlyConfigureModule } from &quot;@tmorin/ceb-inversion-core&quot;
import {
  TestScenarioBuilder,
  TestSuiteBuilder,
} from &quot;@tmorin/ceb-inversion-testing-core&quot;

export const SuiteA = TestSuiteBuilder.get(&quot;ToEmphasize Port&quot;)
  .scenario(
    TestScenarioBuilder.get(&quot;Greeting target is emphasized&quot;)
      .configure((containerBuilder) =&gt; {
        containerBuilder.module(
          OnlyConfigureModule.create(async function () {
            this.registry.registerFactory(&quot;Greeting&quot;, (registry) =&gt; {
              // expect an adapter of the port &quot;ToEmphasize&quot;
              const toEmphasize =
                registry.resolve&lt;(value: string) =&gt; string&gt;(&quot;ToEmphasize&quot;)
              // use the adapter to emphasize the target name
              return `Hello, ${toEmphasize(&quot;john doe&quot;)}`
            })
          })
        )
      })
      .execute((container) =&gt; {
        // resolve the model artifact
        const text = container.registry.resolve&lt;string&gt;(&quot;Greeting&quot;)
        // validate the model artifact works as expected with the tested adapter
        assert.equal(text, &quot;Hello, JOHN DOE!&quot;)
      })
      .build()
  )
  .build()
</code></pre>
<h2 id="mocha-implementation"><a class="header" href="#mocha-implementation">Mocha Implementation</a></h2>
<blockquote>
<p>The Mocha implementation of the testing model is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-inversion-testing-mocha">@tmorin/ceb-inversion-testing-mocha</a>.</p>
</blockquote>
<p>An implementation of the testing model is provided for Mocha.</p>
<p>From the provider point of view, the suites are executed using the MochaTestSuiteExecutorBuilder.</p>
<pre><code class="language-typescript">import { MochaTestSuiteExecutorBuilder } from &quot;@tmorin/ceb-inversion-testing-mocha&quot;
import { OnlyConfigureModule } from &quot;@tmorin/ceb-inversion-core&quot;
import { SuiteA } from &quot;./hexagonal_testing-suite&quot;

describe(&quot;ToEmphasize Adapter&quot;, function () {
  MochaTestSuiteExecutorBuilder.get(SuiteA)
    .configure((containerBuilder) =&gt; {
      containerBuilder.module(
        OnlyConfigureModule.create(async function () {
          this.registry.registerValue(&quot;ToEmphasize&quot;, (value: string) =&gt;
            value.toUpperCase()
          )
        })
      )
    })
    .build()
    .execute()
})
</code></pre>
<h2 id="jest-implementation"><a class="header" href="#jest-implementation">Jest Implementation</a></h2>
<blockquote>
<p>The Jest implementation of the testing model is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-inversion-testing-jest">@tmorin/ceb-inversion-testing-jest</a>.</p>
</blockquote>
<p>An implementation of the testing model is provided for Jest.</p>
<p>From the provider point of view, the suites are executed using the JestTestSuiteExecutorBuilder.</p>
<pre><code class="language-typescript">import { JestTestSuiteExecutorBuilder } from &quot;@tmorin/ceb-inversion-testing-jest&quot;
import { OnlyConfigureModule } from &quot;@tmorin/ceb-inversion-core&quot;
import { SuiteA } from &quot;./hexagonal_testing-suite&quot;

describe(&quot;ToEmphasize Adapter&quot;, function () {
  JestTestSuiteExecutorBuilder.get(SuiteA)
    .configure((containerBuilder) =&gt; {
      containerBuilder.module(
        OnlyConfigureModule.create(async function () {
          this.registry.registerValue(&quot;ToEmphasize&quot;, (value: string) =&gt;
            value.toUpperCase()
          )
        })
      )
    })
    .build()
    .execute()
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messaging"><a class="header" href="#messaging">Messaging</a></h1>
<p><code>&lt;ceb/&gt;</code> provides a built-in solution for the implementation of the application logic which relies on an Event/Message Architecture.</p>
<p>The original purpose is to strictly separate the interaction logic (i.e. the Custom Elements) and the application logic.
The communication between both worlds is handled by an asynchronous API relying on <em>messages</em> transiting within <em>buses</em>.
A <em>message</em> is a simple data structure expressing an action to do, its result or a notification about one of its side effect.
A <em>bus</em> is a component providing a set of commands to emit and receive <em>messages</em>. </p>
<p>The core of the solution is composed of a <em>model</em> and a set of building blocks implementing an Event/Message Architecture.
The reference implementation is a vanilla TypeScript/JavaScript flavor working in almost all JavaScript context: Browser, Node, Electron ...
Additional packages provide support for side concerns like integration, testing ...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>All Event/Message Architectures rely on common concepts.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>A message is a structured piece of information which contains a <em>kind</em>, a set of <em>headers</em> and a <em>body</em>.</p>
<p><code>&lt;ceb/&gt;</code> recognizes three main kinds of messages:</p>
<ul>
<li>A Command expresses the intent of the producer to change the state of the system.</li>
<li>A Query expresses the intent of the producer to know the state of the system.</li>
<li>An Event expresses that something has happened in the past.</li>
</ul>
<p>An additional one, the Result, is used to provide a feedback to the producer within a Request-Reply scenario.</p>
<p><img src="messaging/concepts-messages.png" alt="The hierarchy of the messages" /></p>
<h2 id="message-buses"><a class="header" href="#message-buses">Message Buses</a></h2>
<p>A Message Bus is a component able to handle the sending and reception of messages.</p>
<p>The described messages are transmitted in buses from their producers to eventual receivers.</p>
<p><code>&lt;ceb/&gt;</code> recognizes three kind of buses:</p>
<ul>
<li>The Command Bus dedicated for the Command messages.</li>
<li>The Query Bus dedicated for the Query messages.</li>
<li>The Event Bus dedicated for the Event messages.</li>
</ul>
<p>The Command Bus and Query Bus embraces the Point-to-Point Channel characteristics.
So that, Request-Reply scenario can be implemented, especially for the Query Bus channel where the purpose is get a Result from the query handler.</p>
<p>On the other hand, the Event Bus relies on the Publish-Subscribe Channel characteristics.</p>
<p><img src="messaging/concepts-bus-command.png" alt="The command bus" /></p>
<p><img src="messaging/concepts-bus-query.png" alt="The query bus" /></p>
<p><img src="messaging/concepts-bus-event.png" alt="The event bus" /></p>
<h2 id="gateway"><a class="header" href="#gateway">Gateway</a></h2>
<p>From a user point of view, a gateway is an entry point to produce and consume messages.
It exposes the three message buses: the Command Bus, the Query Bus and the Event Bus.
Additionally, an Observer is also available to track some messaging side cases like error handling.</p>
<p><img src="messaging/concepts-gateway.png" alt="The gateway" /></p>
<h2 id="command-and-query-separation"><a class="header" href="#command-and-query-separation">Command And Query Separation</a></h2>
<p>The CQS design pattern emphases a strict separation of the APIs about read and write operations.
At the code level, its implementation is the expressiveness of dedicated programming artifacts for each concern: wrote operations vs read operations.</p>
<p><img src="messaging/concepts-cqs-base-level-code.png" alt="The base at the code level" /></p>
<p>On an upper level, at the Bounded Context one, the CQS design pattern can be implemented leveraging on messaging systems.</p>
<ol>
<li>The Bounded Context's Facade creates and dispatches Commands and Queries to the Gateway.</li>
<li>Then, the Gateway delegates to the right handler the execution of the action.</li>
<li>Finally, the implementations of the handlers leverage on the model artifacts (Entity, Service ...) to fulfill the requests.</li>
</ol>
<p><img src="messaging/concepts-cqs-base-level-bounded-context.png" alt="The base at the bounded context level" /></p>
<p>The logic of the command handler produces an output which is composed of two items:</p>
<ul>
<li>a result which will be sent back to the requester</li>
<li>as well as an additional set of events which will be published on the event bus</li>
</ul>
<p><img src="messaging/concepts-cqs-command.png" alt="The command handling" /></p>
<p>On the other side, the logic of the query handler produces a result which will be sent back to the requester</p>
<p><img src="messaging/concepts-cqs-query.png" alt="The query handling" /></p>
<h2 id="command-and-query-responsibility-segregation"><a class="header" href="#command-and-query-responsibility-segregation">Command And Query Responsibility Segregation</a></h2>
<p>When CQS is applied at the software architecture level, an adaptation of the command handling and query handling can be done to strictly segregate the model for the commands and the model for the queries.
There are many strategies to feed the query model based on the operations made by the command one.
One of them is to leverage on the events published by the command handling part.
The ways to feed the query model by events depends on the nature of the application.
Some can just work with transient events, whereas others may require a more robust approach based on queues or streams of events potentially persisted.</p>
<p><img src="messaging/concepts-cqrs-base-level-bounded-context.png" alt="From CQS to CQRS at the bounded context level" /></p>
<p>Additionally, the usage of Events can lead to a model driven by the Event Sourcing approach where the produced Event are not just a side effect of the command handling but also its source of truth.</p>
<h2 id="location-transparency"><a class="header" href="#location-transparency">Location Transparency</a></h2>
<p>Location Transparency is the ability to share or get resources without the knowledge of their localizations.</p>
<p>Because of the introduction of the messages and their underlying buses provided by the Gateway, the communication between Bounded Contexts is natively transparent.
Therefore, only infrastructural components will have to be adapted to move a Bound Context from its original Monolith to a dedicated side Microlith.</p>
<p><img src="messaging/concepts-location-transparency-monolith.png" alt="The original Monolith" /></p>
<p><img src="messaging/concepts-location-transparency-microlith.png" alt="The introduction of a Microlith" /></p>
<p>Additionally, scaling of Bounded Contexts can be done leveraging only on infrastructural components.</p>
<p><img src="messaging/concepts-location-transparency-scaling.png" alt="The scaling of a Bounded Context" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages-1"><a class="header" href="#messages-1">Messages</a></h1>
<blockquote>
<p>The definition of the messages is part of the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-core">@tmorin/ceb-messaging-core</a>.</p>
</blockquote>
<h2 id="anatomy-of-a-message"><a class="header" href="#anatomy-of-a-message">Anatomy of a message</a></h2>
<p>A message is a data structure composed of three properties: <code>kind</code>, <code>headers</code> and <code>body</code>.</p>
<table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td><code>kind</code></td><td>Provide the intention of the message producer.</td></tr>
<tr><td><code>headers</code></td><td>Provide information to the messaging system to handle the message. The headers are a set of arbitrary key/value entries. Two entries are expected for each message: the <code>messageType</code> and the <code>messageId</code>.</td></tr>
<tr><td><code>body</code></td><td>An arbitrary set of information expected by the receiver.</td></tr>
</tbody></table>
<p><img src="messaging/messages-message.png" alt="The Message" /></p>
<h2 id="the-commands"><a class="header" href="#the-commands">The commands</a></h2>
<p>A Command is a data structure matching the Message one.</p>
<table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td><code>kind</code></td><td>The value is always <code>command</code>.</td></tr>
<tr><td><code>headers.messageType</code></td><td>Help the messaging system to route the message to the right command handler.</td></tr>
</tbody></table>
<p><img src="messaging/messages-command.png" alt="The Command" /></p>
<p>Commands are handled by Command Handlers.
By convention, a command type should only be processed by one Command Handler implementation and process only once.
The main purpose of a command handler is to interact with model artifacts to mutate the state of a system.
The underlying side effects can be described by a Result and/or a set of Events.</p>
<h2 id="the-queries"><a class="header" href="#the-queries">The queries</a></h2>
<p>A Query is a data structure matching the Message one.</p>
<table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td><code>kind</code></td><td>The value is always <code>query</code>.</td></tr>
<tr><td><code>headers.messageType</code></td><td>Help the messaging system to route the message to the right query handler.</td></tr>
</tbody></table>
<p><img src="messaging/messages-query.png" alt="The Query" /></p>
<p>Queries are handled by Query Handlers.
By convention, a query type can be processed by different Command Handlers implementations and process more than once.
The main purpose of a query handler is to interact with model artifacts to gather data and build a view of the system's state.
The view is finally sent back to the requester within a Result.</p>
<h2 id="the-results"><a class="header" href="#the-results">The results</a></h2>
<p>A Result is a data structure matching the Message one.</p>
<table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td><code>kind</code></td><td>The value is always <code>result</code>.</td></tr>
<tr><td><code>headers.messageType</code></td><td>Help requester to handle the result, i.e. success vs failure.</td></tr>
<tr><td><code>headers.originalMessageId</code></td><td>It's the <code>messageId</code> of the related command or query. It helps the requester to distinguish to which command or query a result belongs to.</td></tr>
</tbody></table>
<p><img src="messaging/messages-result.png" alt="The Result" /></p>
<h2 id="the-events"><a class="header" href="#the-events">The events</a></h2>
<p>An Event is a data structure matching the Message one.</p>
<table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td><code>kind</code></td><td>The value is always <code>event</code>.</td></tr>
<tr><td><code>headers.messageType</code></td><td>Help the messaging system to route the message to the right event listeners.</td></tr>
</tbody></table>
<p><img src="messaging/messages-event.png" alt="The Event" /></p>
<p>Events are listened by Event Listeners.
By convention, an event type can be listened by many Event listeners.
The main purpose of an event listener is to react on the event.</p>
<h2 id="message-construction"><a class="header" href="#message-construction">Message Construction</a></h2>
<p>Messages are simple vanilla JavaScript objects.
For instance to create a command <code>Greeting</code>, the following snippet is enough.</p>
<pre><code class="language-javascript">const greetingCmd = {
  kind: &quot;command&quot;,
  headers: {
    messageType: &quot;Greeting&quot;,
    messageId: &quot;command-0&quot;
  },
  body: &quot;Hello, World!&quot;
}
</code></pre>
<p>However, manual creation of messages is error-prone and not really DRY.
Therefore, a <em>builder</em> is provided to, at least, build messages which are <em>technically</em> valid.</p>
<p>Creation of commands using the MessageBuilder:</p>
<pre><code class="language-typescript">import { MessageBuilder } from &quot;@tmorin/ceb-messaging-core&quot;

// create a command
const aCommandA = MessageBuilder.command(&quot;CommandA&quot;)
  // set a custom identifier
  .identifier(&quot;command-1&quot;)
  // add an header entry
  .headers({ k1: &quot;v1&quot; })
  // set a body
  .body(&quot;a body&quot;)
  // build the result
  .build()
</code></pre>
<p>Creation of queries using the MessageBuilder:</p>
<pre><code class="language-typescript">import { MessageBuilder } from &quot;@tmorin/ceb-messaging-core&quot;

// create a query
const aQueryA = MessageBuilder.query(&quot;QueryA&quot;)
  // set a custom identifier
  .identifier(&quot;query-1&quot;)
  // add an header entry
  .headers({ k1: &quot;v1&quot; })
  // set a body
  .body(&quot;a body&quot;)
  // build the result
  .build()
</code></pre>
<p>Creation of events using the MessageBuilder:</p>
<pre><code class="language-typescript">import { MessageBuilder } from &quot;@tmorin/ceb-messaging-core&quot;

// create an event
const anEventA = MessageBuilder.event(&quot;EventA&quot;)
  // set a custom identifier
  .identifier(&quot;event-1&quot;)
  // add an header entry
  .headers({ k1: &quot;v1&quot; })
  // set a body
  .body(&quot;a body&quot;)
  // build the result
  .build()
</code></pre>
<p>Creation of results using the MessageBuilder:</p>
<pre><code class="language-typescript">import { MessageBuilder } from &quot;@tmorin/ceb-messaging-core&quot;

// create a basic command
const commandA = MessageBuilder.command(&quot;CommandA&quot;).build()

// create a result
const resultA = MessageBuilder.result(commandA)
  // override the message type, by default it's `result`
  .type(&quot;custom-type&quot;)
  // set a custom identifier
  .identifier(&quot;result-1&quot;)
  // add an header entry
  .headers({ k1: &quot;v1&quot; })
  // set a body
  .body(&quot;a body&quot;)
  // build the result
  .build()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gateway-1"><a class="header" href="#gateway-1">Gateway</a></h1>
<blockquote>
<p>The definition of the Gateway is part of the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-core">@tmorin/ceb-messaging-core</a>.</p>
</blockquote>
<p>The Gateway is a set of interfaces acting as an entry point to the messaging world.
It can be used to send or handle messages but also to observe the implementations' behavior.</p>
<p>A Gateway provides accessors to the main buses: the CommandBus, the QueryBus and the EventBus.
A remaining accessor provides an observable view point of the Gateway.</p>
<p>A Gateway should be ready to used once created.
Its end-of-life is triggered with its method <code>dispose()</code>.
Its purpose is to release all stateful stuff.
So that, once invoked, the Gateway cannot be used anymore.</p>
<p><img src="messaging/gateway-overview.png" alt="The Gateway" /></p>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>The CommandBus provides methods to interact with the Point-to-Point Channel which handles the commands.
The CommandBus supports the one-way or two-way conversations.</p>
<p>On the receiver side, the handled commands are registered using the method <code>handle()</code>.
The method expects the type of the command to handle as well as its handler.
The handler is a <em>callback</em> function which will be invoked once a command is received.
A handler may return an output which may be composed of an optional Result and/or an optional set of Events.
If expected, the Result will be sent back to the sender.
About the set of Events, they will be published on the EventBus.
At any time, a handler can be unregistered using the Removable object returned by the method <code>handler()</code>.</p>
<p>On the sender side, those requiring a one-way conversation must use the method <code>executeAndForget()</code>.
Within this conversation style, the command sender doesn't expect a Result from the receiver side.
So that, the receiver and server sides don't need to handle the Request-Reply pattern.</p>
<p>However, senders requiring a two-way conversation must use the method <code>execute()</code>.</p>
<p><img src="messaging/gateway-commands.png" alt="The CommandBus" /></p>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>The QueryBus provides methods to interact with the Point-to-Point Channel which handles the queries.
The QueryBus supports only the two-way conversations.</p>
<p>On the receiver side, the handled queries are registered using the method <code>handle()</code>.
At any time, a handler can be unregistered using the Removable object returned by the method <code>handler()</code>.</p>
<p>On the sender side, the queries are sent to the bus and the replies received using the method <code>execute()</code>.</p>
<p><img src="messaging/gateway-queries.png" alt="The QueryBus" /></p>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>The EventBus provides methods to interact with the Publish-Subscribe Channel which handles the events.</p>
<p>The publisher must use the method <code>publish()</code> to publish events.
On the other side, the subscribers must use the method <code>subscribe()</code> to subscribe on published events.
At any time, a subscription can be disposed using the Removable object returned by the method <code>subscribe()</code>.</p>
<p><img src="messaging/gateway-events.png" alt="The EventBus" /></p>
<h2 id="observer"><a class="header" href="#observer">Observer</a></h2>
<p>The Observer is a <em>view</em> side of the Control Bus.
It provides an entry point to observe the main buses: the CommandBus, the QueryBus and the EventBus.</p>
<p><img src="messaging/gateway-observer.png" alt="The GatewayObserver" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inversion-1"><a class="header" href="#inversion-1">Inversion</a></h1>
<blockquote>
<p>The definition of the Inversion module is part of the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-inversion">@tmorin/ceb-messaging-inversion</a>.</p>
</blockquote>
<p>Command and Query handlers as well as Event listeners can be discovered and managed by Inversion on the container initialization.
The module <code>MessagingModule</code> takes care of the discovery, registration and also disposition of handlers and listeners at the container end of life.</p>
<p>Discoverable Command handlers must match the <code>DiscoverableCommandHandler</code> interface.</p>
<pre><code class="language-typescript">import {
  Command,
  Event,
  MessageBuilder,
  Result,
} from &quot;@tmorin/ceb-messaging-core&quot;
import { DiscoverableCommandHandler } from &quot;@tmorin/ceb-messaging-inversion&quot;

// create the handler using the &quot;implementation&quot; way
export class GreetSomebodyHandler
  implements
    DiscoverableCommandHandler&lt;
      Command&lt;string&gt;,
      Result&lt;string&gt;,
      Array&lt;Event&lt;string&gt;&gt;
    &gt;
{
  // the type of the Command to handle
  type = &quot;GreetSomebody&quot;

  // the handler
  handler(command: Command&lt;string&gt;) {
    // create the greeting text
    const result = MessageBuilder.result(command)
      .body(`Hello, ${command.body}!`)
      .build()
    // create the event
    const events = [
      MessageBuilder.event(&quot;SomeoneHasBeenGreeted&quot;).body(command.body).build(),
    ]
    // return the output
    return { result, events }
  }
}
</code></pre>
<p>Discoverable Query handlers must match the <code>DiscoverableQueryHandler</code> interface.</p>
<pre><code class="language-typescript">import { MessageBuilder, Query, Result } from &quot;@tmorin/ceb-messaging-core&quot;
import { DiscoverableQueryHandler } from &quot;@tmorin/ceb-messaging-inversion&quot;

// create the handler using the &quot;implementation&quot; way
export class WhatTimeIsItHandler
  implements DiscoverableQueryHandler&lt;Query&lt;void&gt;, Result&lt;string&gt;&gt;
{
  // the type of the Query to handle
  type = &quot;WhatTimeIsIt&quot;

  // the handler
  handler(query: Query&lt;void&gt;) {
    return MessageBuilder.result(query).body(new Date().toISOString()).build()
  }
}
</code></pre>
<p>Discoverable Event listeners must match the <code>DiscoverableEventListener</code> interface.</p>
<pre><code class="language-typescript">import { Event } from &quot;@tmorin/ceb-messaging-core&quot;
import { DiscoverableEventListener } from &quot;@tmorin/ceb-messaging-inversion&quot;

// create the listener using the &quot;object&quot; way
export const SOMEONE_HAS_BEEN_GREETED_LISTENER: DiscoverableEventListener&lt;
  Event&lt;string&gt;
&gt; = {
  // the type of the Event to handle
  type: &quot;SomeoneHasBeenGreeted&quot;,
  // the handler
  listener: (event: Event&lt;string&gt;) =&gt; {
    console.info(`${event.body} has been greeted`)
  },
}
</code></pre>
<p>To be discoverable the handlers and listeners must be registered in the Container's Registry with the right Registry Key.</p>
<ul>
<li><code>DiscoverableCommandHandlerSymbol</code> for the Command handlers</li>
<li><code>DiscoverableQueryHandlerSymbol</code> for the Query handlers</li>
<li><code>DiscoverableEventListenerSymbol</code> for the Event listeners</li>
</ul>
<pre><code class="language-typescript">import { AbstractModule } from &quot;@tmorin/ceb-inversion-core&quot;
import { GreetSomebodyHandler } from &quot;./inversion-discovery-command&quot;
import { WhatTimeIsItHandler } from &quot;./inversion-discovery-query&quot;
import { SOMEONE_HAS_BEEN_GREETED_LISTENER } from &quot;./inversion-discovery-event&quot;
import {
  DiscoverableCommandHandlerSymbol,
  DiscoverableEventListenerSymbol,
  DiscoverableQueryHandlerSymbol,
} from &quot;@tmorin/ceb-messaging-inversion&quot;

// define a &quot;regular&quot; Module
export class DiscoverableStuffModule extends AbstractModule {
  async configure() {
    // register the command handler
    this.registry.registerValue(
      DiscoverableCommandHandlerSymbol,
      new GreetSomebodyHandler()
    )
    // register the query handler
    this.registry.registerFactory(
      DiscoverableQueryHandlerSymbol,
      () =&gt; new WhatTimeIsItHandler()
    )
    // register the event listener
    this.registry.registerValue(
      DiscoverableEventListenerSymbol,
      SOMEONE_HAS_BEEN_GREETED_LISTENER
    )
  }
}
</code></pre>
<p>Finally, the module <code>MessagingModule</code> and those registering discoverable handlers and listeners must be registered as other modules.</p>
<pre><code class="language-typescript">import { ContainerBuilder } from &quot;@tmorin/ceb-inversion-core&quot;
import {
  Gateway,
  GatewaySymbol,
  MessageBuilder,
} from &quot;@tmorin/ceb-messaging-core&quot;
import { DiscoverableStuffModule } from &quot;./inversion-discovery-module&quot;
import { MessagingModule } from &quot;@tmorin/ceb-messaging-inversion&quot;
import { SimpleModule } from &quot;@tmorin/ceb-messaging-simple-inversion&quot;

ContainerBuilder.get()
  // register the module which discovers the handlers and listeners
  .module(new MessagingModule())
  // register the module which provide a Gateway instance
  .module(new SimpleModule())
  // register the module which contain the discoverable handlers and listeners
  .module(new DiscoverableStuffModule())
  .build()
  .initialize()
  .then(async (container) =&gt; {
    // resolve the gateway
    const gateway = container.registry.resolve&lt;Gateway&gt;(GatewaySymbol)

    // register an event listener
    gateway.events.subscribe(&quot;SomeoneHasBeenGreeted&quot;, (event) =&gt; {
      console.info(`${event.body} has been greeted`)
    })

    // create and execute the GreetSomebody command
    const greetSomebody = MessageBuilder.command(&quot;GreetSomebody&quot;)
      .body(&quot;World&quot;)
      .build()
    const cmdResult = await gateway.commands.execute(greetSomebody)
    console.info(`the greeting text: ${cmdResult.body}`)

    // create and execute the WhatTimeIsIt query
    const whatTimeIsIt = MessageBuilder.query(&quot;WhatTimeIsIt&quot;)
      .body(&quot;World&quot;)
      .build()
    const qryResult = await gateway.queries.execute(whatTimeIsIt)
    console.info(`the time: ${qryResult.body}`)

    return container.dispose()
  })
  .catch((e) =&gt; console.error(e))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-implementation"><a class="header" href="#reference-implementation">Reference Implementation</a></h1>
<blockquote>
<p>The reference implementation is defined in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-simple">@tmorin/ceb-messaging-simple</a>.</p>
</blockquote>
<p>The reference implementation relies on an in-memory and single process approach.
So that, the implementation is free of network or any other concerns related to distributed systems.</p>
<h2 id="the-simplegateway"><a class="header" href="#the-simplegateway">The SimpleGateway</a></h2>
<p>A SimpleGateway instance can be got from the following three approaches: the global instance, the factory method or the constructor.</p>
<h3 id="the-global-instance"><a class="header" href="#the-global-instance">The global instance</a></h3>
<p>A global instance of the SimpleGateway is available from the static field <code>SimpleGateway.GOBAL</code>.
It's a lazy property, in fact the instance is only created once at its first get.</p>
<pre><code class="language-typescript">import { MessageBuilder } from &quot;@tmorin/ceb-messaging-core&quot;
import { SimpleGateway } from &quot;@tmorin/ceb-messaging-simple&quot;

// create an event and publish it using the global SimpleGateway instance
const event = MessageBuilder.event(&quot;EventA&quot;).build()
SimpleGateway.GLOBAL.events.publish(event)
</code></pre>
<h3 id="the-factory-method"><a class="header" href="#the-factory-method">The factory method</a></h3>
<p>A SimpleGateway instance can be easily created using the factory method, i.e. the static method <code>SimpleGateway.create()</code>.
The method returns a fresh new SimpleGateway instance at each call.</p>
<pre><code class="language-typescript">import { Gateway, MessageBuilder } from &quot;@tmorin/ceb-messaging-core&quot;
import { SimpleGateway } from &quot;@tmorin/ceb-messaging-simple&quot;

// create a SimpleGateway instance
const gateway: Gateway = SimpleGateway.create()

// create an event and publish it
const event = MessageBuilder.event(&quot;EventA&quot;).build()
gateway.events.publish(event)

// dispose the created SimpleGateway
gateway.dispose().catch((e) =&gt; console.error(e))
</code></pre>
<h3 id="the-constructor"><a class="header" href="#the-constructor">The constructor</a></h3>
<p>The constructor approach provides a fine grain control of the Gateway dependencies: the CommandBus, the QueryBus, the EventBus and the GatewayObserver. </p>
<pre><code class="language-typescript">import { GatewayEmitter, MessageBuilder } from &quot;@tmorin/ceb-messaging-core&quot;
import {
  SimpleCommandBus,
  SimpleEventBus,
  SimpleGateway,
  SimpleQueryBus,
} from &quot;@tmorin/ceb-messaging-simple&quot;

// create the SimpleGateway dependencies
const emitter = new GatewayEmitter()
const events = new SimpleEventBus(emitter)
const commands = new SimpleCommandBus(events, emitter)
const queries = new SimpleQueryBus(emitter)

// create a SimpleGateway instance
const gateway = new SimpleGateway(events, commands, queries, emitter)

// create an event and publish it
const event = MessageBuilder.event(&quot;EventA&quot;).build()
gateway.events.publish(event)

// dispose the created SimpleGateway
gateway.dispose().catch((e) =&gt; console.error(e))
</code></pre>
<h2 id="the-inversion-module"><a class="header" href="#the-inversion-module">The Inversion Module</a></h2>
<p>The package provides an Inversion Module which can be used to create (optionally) and publish the SimpleGateway instance on the registry.</p>
<p>Create a container with the default module behavior, i.e. the SimpleGateway will be created from scratch automatically:</p>
<pre><code class="language-typescript">import { ContainerBuilder } from &quot;@tmorin/ceb-inversion-core&quot;
import {
  Gateway,
  GatewaySymbol,
  MessageBuilder,
} from &quot;@tmorin/ceb-messaging-core&quot;
import { SimpleModule } from &quot;@tmorin/ceb-messaging-simple-inversion&quot;

ContainerBuilder.get()
  // let the module created it-self the SimpleGateway instance
  .module(new SimpleModule())
  .build()
  .initialize()
  .then((container) =&gt; {
    // resolve the gateway
    const gateway = container.registry.resolve&lt;Gateway&gt;(GatewaySymbol)
    // publish a simple message
    gateway.events.publish(MessageBuilder.event(&quot;Hello&quot;).build())
  })
  .catch((e) =&gt; console.error(e))
</code></pre>
<p>Create a container with a provided SimpleGateway instance:</p>
<pre><code class="language-typescript">import { ContainerBuilder } from &quot;@tmorin/ceb-inversion-core&quot;
import {
  Gateway,
  GatewaySymbol,
  MessageBuilder,
} from &quot;@tmorin/ceb-messaging-core&quot;
import { SimpleGateway } from &quot;@tmorin/ceb-messaging-simple&quot;
import { SimpleModule } from &quot;@tmorin/ceb-messaging-simple-inversion&quot;

ContainerBuilder.get()
  .module(
    new SimpleModule({
      // the provided instance, there the GLOBAL one
      gateway: SimpleGateway.GLOBAL,
    })
  )
  .build()
  .initialize()
  .then((container) =&gt; {
    // resolve the gateway
    const gateway = container.registry.resolve&lt;Gateway&gt;(GatewaySymbol)
    // publish a simple message
    gateway.events.publish(MessageBuilder.event(&quot;Hello&quot;).build())
  })
  .catch((e) =&gt; console.error(e))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adapters"><a class="header" href="#adapters">Adapters</a></h1>
<h2 id="the-dom-adapter"><a class="header" href="#the-dom-adapter">The DOM Adapter</a></h2>
<blockquote>
<p>The adapter is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-adapter-dom">@tmorin/ceb-messaging-adapter-dom</a>.</p>
</blockquote>
<p>The DOM adapter provides a bridges between the DOM event handling system and a Gateway.
The main purpose is to drive the development of UI components with an Event/Message Architecture approach without dependencies or additional library.</p>
<p><img src="messaging/adapter-dom-command.png" alt="Handling of Command messages" /></p>
<p><img src="messaging/adapter-dom-query.png" alt="Handling of Query messages" /></p>
<p><img src="messaging/adapter-dom-event.png" alt="Handling of Event messages" /></p>
<h2 id="the-electron-adapter"><a class="header" href="#the-electron-adapter">The Electron Adapter</a></h2>
<blockquote>
<p>The adapter is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-adapter-electron">@tmorin/ceb-messaging-adapter-electron</a>.</p>
</blockquote>
<p>The Electron adapter provides a bridges between the Electron IPC Event Emitter and a Gateway.
The main purpose is to standardize the communication flows between the <em>main</em> context and the <em>renderer</em> contexts based on the Location Transparency pattern.</p>
<p>The bridge is bidirectional for all message kinds.
However, messages dispatched from a Renderer context are only forwarded to the Main context.
That means sibling Renderer contexts won't get the messages.</p>
<p><img src="messaging/adapter-electron-renderer_to_main.png" alt="From Renderer to Main" /></p>
<p>However, on the other side, messages dispatched from the Main Context are forwarded to all Renderer contexts.</p>
<p><img src="messaging/adapter-electron-main_to_renderer.png" alt="From Main to Renderer" /></p>
<h2 id="the-purify-adapter"><a class="header" href="#the-purify-adapter">The Purify Adapter</a></h2>
<blockquote>
<p>The adapter is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-messaging-adapter-purify">@tmorin/ceb-messaging-adapter-purify</a>.</p>
</blockquote>
<p>The Purify adapter provides an adapter of Gateways which integrates Purify types.
The main purpose is to provide a hint of functional programing style for the processing of commands, queries and results.</p>
<p><img src="messaging/adapter-purify.png" alt="The buses hierarchy" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elements"><a class="header" href="#elements">Elements</a></h1>
<p><code>&lt;ceb/&gt;</code> relies on the <a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder Pattern</a> and also <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">Decorators</a> to define, enhance and finally register Custom Elements.</p>
<p>The main builder <a href="elements/ElementBuilder.html">ElementBuilder</a> handles the definition and registration of Custom Elements.</p>
<p>Then, other builders can be used to enhance it:</p>
<ul>
<li><a href="elements/AttributeBuilder.html">AttributeBuilder</a>: to define attributes and react on changes</li>
<li><a href="elements/FieldBuilder.html">FieldBuilder</a>: to define fields (property/attribute) and react on changes</li>
<li><a href="elements/OnBuilder.html">OnBuilder</a>: to listen to DOM events</li>
<li><a href="elements/ContentBuilder.html">ContentBuilder</a>: to initialize the light or shadow DOM</li>
<li><a href="elements/TemplateBuilder.html">TemplateBuilder</a>: to path the DOM of the custom element</li>
<li><a href="elements/ReferenceBuilder.html">ReferenceBuilder</a>: to get reference of children nodes</li>
<li><a href="elements/AttributePropagationBuilder.html">AttributePropagationBuilder</a>: to delegate attribute mutations to child nodes</li>
<li><a href="elements/PropertyDelegationBuilder.html">PropertyDelegationBuilder</a>: to delegate the property accesses to a single child node</li>
</ul>
<p>For convenience, the package <a href="https://www.npmjs.com/package/@tmorin/ceb-bundle-web">@tmorin/ceb-bundle-web</a> provides all built-in artifacts for the Custom Elements authoring.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elementbuilder"><a class="header" href="#elementbuilder">ElementBuilder</a></h1>
<blockquote>
<p>The builder is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-elements-core">@tmorin/ceb-elements-core</a>.</p>
</blockquote>
<p>The class <code>ElementBuilder</code> provides services to define and register a Custom Element.</p>
<h2 id="challenge-yourself"><a class="header" href="#challenge-yourself">Challenge yourself</a></h2>
<p>Will you be able to ...</p>
<ol>
<li>change the tag name to <code>&lt;my-greeting&gt;&lt;/my-greeting&gt;</code> without changing the class name?</li>
<li>transform <code>SimpleGreeting</code> as an extension of <code>h1</code>, so that can be created with <code>&lt;h1 is=&quot;my-greeting&quot;&gt;&lt;/h1&gt;</code>? <small>the class of <code>h1</code> is <code>HTMLHeadingElement</code></small></li>
</ol>
<p class="codepen" data-height="400" data-theme-id="light" data-default-tab="js,result" data-slug-hash="ExmLwwd" data-editable="true" data-user="tmorin" style="height: 400px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/tmorin/pen/ExmLwwd">
  &lt;ceb/&gt; ~ challenge/ElementBuilder</a> by Thibault Morin (<a href="https://codepen.io/tmorin">@tmorin</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<h2 id="define-a-regular-custom-element"><a class="header" href="#define-a-regular-custom-element">Define a regular Custom Element</a></h2>
<pre><code class="language-typescript">import { ElementBuilder } from &quot;@tmorin/ceb-elements-core&quot;

// defines and register the custom element class
@ElementBuilder.get().decorate()
class SimpleGreeting extends HTMLElement {
  constructor(public name = &quot;World&quot;) {
    super()
  }

  connectedCallback() {
    this.textContent = `Hello, ${this.name}!`
  }
}
</code></pre>
<p>Once registered, the Custom Element can be created with three different styles: markup, Object-Oriented and, hybrid.</p>
<p>The first one relies on the tag name of the Custom Element within the markup of an HTML document.</p>
<pre><code class="language-typescript">document.body.innerHTML = `&lt;simple-greeting&gt;&lt;/simple-greeting&gt;`
</code></pre>
<p>The second one relies on the Object-Oriented nature of the Custom Element.
Basically, the class can be instantiated, and the created object can be then append to the DOM.</p>
<pre><code class="language-typescript">const helloJohn: SimpleGreeting = new SimpleGreeting(&quot;John&quot;)
document.body.appendChild(helloJohn)
</code></pre>
<p>The last one lies between the markup and OO style.</p>
<pre><code class="language-typescript">const helloDoe: SimpleGreeting = document.createElement(&quot;simple-greeting&quot;)
helloDoe.name = &quot;Doe&quot;
document.body.appendChild(helloDoe)
</code></pre>
<h2 id="define-an-extension-of-a-native-element"><a class="header" href="#define-an-extension-of-a-native-element">Define an extension of a native Element</a></h2>
<pre><code class="language-typescript">import { ElementBuilder } from &quot;@tmorin/ceb-elements-core&quot;

// defines and register the custom element class
@ElementBuilder.get().extends(&quot;p&quot;).decorate()
class SimpleGreetingParagraph extends HTMLParagraphElement {
  constructor(public name = &quot;World&quot;) {
    super()
  }

  connectedCallback() {
    this.textContent = `Hello, ${this.name}!`
  }
}
</code></pre>
<p>Once registered, the Custom Element can be created like the regular one.
However, because of the extension of a native Element, the creation expects additional information. </p>
<p>The creation with the markup style:</p>
<pre><code class="language-typescript">document.body.innerHTML = `&lt;p is=&quot;simple-greeting-paragraph&quot;&gt;&lt;/p&gt;`
</code></pre>
<p>The creation with the Object-Oriented style:</p>
<pre><code class="language-typescript">const helloJohn: SimpleGreetingParagraph = new SimpleGreeting(&quot;John&quot;)
document.body.appendChild(helloJohn)
</code></pre>
<p>The creation with the hybrid style:</p>
<pre><code class="language-typescript">const helloDoe: SimpleGreetingParagraph = document.createElement(&quot;p&quot;, {
    extends: &quot;is&quot;
})
helloDoe.name = &quot;Doe&quot;
document.body.appendChild(helloDoe)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributebuilder"><a class="header" href="#attributebuilder">AttributeBuilder</a></h1>
<blockquote>
<p>The builder is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-elements-builders">@tmorin/ceb-elements-builders</a>.</p>
</blockquote>
<p>The builder handles the initialization of an attribute as well as the registration of its listeners.</p>
<h2 id="challenge-yourself-1"><a class="header" href="#challenge-yourself-1">Challenge yourself</a></h2>
<p>Will you be able to ...</p>
<ol>
<li>display <code>Hello, John Doe!</code> just setting the attribute <code>name</code>?</li>
<li>change the attribute name to <code>alt-name</code> without changing the method name?</li>
</ol>
<p class="codepen" data-height="400" data-theme-id="light" data-default-tab="js,result" data-slug-hash="rNmvGqq" data-editable="true" data-user="tmorin" style="height: 400px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/tmorin/pen/rNmvGqq">
  &lt;ceb/&gt; ~ challenge/AttributeBuilder</a> by Thibault Morin (<a href="https://codepen.io/tmorin">@tmorin</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fieldbuilder"><a class="header" href="#fieldbuilder">FieldBuilder</a></h1>
<blockquote>
<p>The builder is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-elements-builders">@tmorin/ceb-elements-builders</a>.</p>
</blockquote>
<p>The builder binds a property to an attribute.
So that, the value is available and mutable from both sides.</p>
<h2 id="challenge-yourself-2"><a class="header" href="#challenge-yourself-2">Challenge yourself</a></h2>
<p>Will you be able to ...</p>
<ol>
<li>display <code>Hello, John Doe!</code> just setting the property <code>name</code>?</li>
<li>change the attribute name to <code>alt-name</code> without changing the property name?</li>
</ol>
<p class="codepen" data-height="400" data-theme-id="light" data-default-tab="js,result" data-slug-hash="mdmLqEW" data-editable="true" data-user="tmorin" style="height: 400px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/tmorin/pen/mdmLqEW">
  &lt;ceb/&gt; ~ challenge/FieldBuilder</a> by Thibault Morin (<a href="https://codepen.io/tmorin">@tmorin</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="onbuilder"><a class="header" href="#onbuilder">OnBuilder</a></h1>
<blockquote>
<p>The builder is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-elements-builders">@tmorin/ceb-elements-builders</a>.</p>
</blockquote>
<p>The builder handles the addition and removal of DOM event listeners.</p>
<h2 id="challenge-yourself-3"><a class="header" href="#challenge-yourself-3">Challenge yourself</a></h2>
<p>Will you be able to ...</p>
<ol>
<li>display <code>Hello, World!</code> only when the <code>click</code> event comes from a <code>button</code>? <small>c.f. Event Delegation ;)</small></li>
<li>display <code>Hello, World!</code> only on double click? <small>there is a native event for that ;)</small></li>
</ol>
<p class="codepen" data-height="400" data-theme-id="light" data-default-tab="js,result" data-slug-hash="KKmRyWG" data-editable="true" data-user="tmorin" style="height: 400px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/tmorin/pen/KKmRyWG">
  &lt;ceb/&gt; ~ challenge/OnBuilder</a> by Thibault Morin (<a href="https://codepen.io/tmorin">@tmorin</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contentbuilder"><a class="header" href="#contentbuilder">ContentBuilder</a></h1>
<blockquote>
<p>The builder is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-elements-builders">@tmorin/ceb-elements-builders</a>.</p>
</blockquote>
<p>The builder handles the initialization of the HTML content of the Custom Element.</p>
<h2 id="challenge-yourself-4"><a class="header" href="#challenge-yourself-4">Challenge yourself</a></h2>
<p>Will you be able ...</p>
<ol>
<li>to display <code>Hello, John Doe!</code>?</li>
<li>to render into a Shadow DOM?</li>
</ol>
<p class="codepen" data-height="400" data-theme-id="light" data-default-tab="js,result" data-slug-hash="LYymeaB" data-editable="true" data-user="tmorin" style="height: 400px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/tmorin/pen/LYymeaB">
  &lt;ceb/&gt; ~ challenge/ContentBuilder</a> by Thibault Morin (<a href="https://codepen.io/tmorin">@tmorin</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templatebuilder"><a class="header" href="#templatebuilder">TemplateBuilder</a></h1>
<blockquote>
<p>The builder is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-elements-builders">@tmorin/ceb-elements-builders</a>.</p>
</blockquote>
<p>The builder handles the integration of a templating solution to update the content of the Custom Element.</p>
<p>The builder doesn't provide the templating solution out of the box.
However, the library provides a built-in solution described later, c.f. <a href="elements/../templating/README.html">Templating</a> .</p>
<h2 id="challenge-yourself-5"><a class="header" href="#challenge-yourself-5">Challenge yourself</a></h2>
<p>Will you be able to ...</p>
<ol>
<li>display <code>Hello, John Doe!</code> calling the <code>render</code> method?</li>
<li>render into a Shadow DOM?</li>
<li>render into a Grey DOM?</li>
</ol>
<p class="codepen" data-height="400" data-theme-id="light" data-default-tab="js,result" data-slug-hash="ExmLQYE" data-editable="true" data-user="tmorin" style="height: 400px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/tmorin/pen/ExmLQYE">
  &lt;ceb/&gt; ~ challenge/TemplateBuilder</a> by Thibault Morin (<a href="https://codepen.io/tmorin">@tmorin</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencebuilder"><a class="header" href="#referencebuilder">ReferenceBuilder</a></h1>
<blockquote>
<p>The builder is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-elements-builders">@tmorin/ceb-elements-builders</a>.</p>
</blockquote>
<p>The builder enhances a readonly property to execute a CSS Selector once the property is get.
So that, a property of the Custom Element can always be related to a child element or a set of child elements.</p>
<h2 id="challenge-yourself-6"><a class="header" href="#challenge-yourself-6">Challenge yourself</a></h2>
<p>Will you be able to ...</p>
<ol>
<li>implement the method <code>sayHelloJohnDoe()</code> to display <code>Hello, John Doe!</code>?</li>
</ol>
<p class="codepen" data-height="400" data-theme-id="light" data-default-tab="js,result" data-slug-hash="zYwjaMy" data-editable="true" data-user="tmorin" style="height: 400px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/tmorin/pen/zYwjaMy">
  &lt;ceb/&gt; ~ challenge/ReferenceBuilder</a> by Thibault Morin (<a href="https://codepen.io/tmorin">@tmorin</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributepropagationbuilder"><a class="header" href="#attributepropagationbuilder">AttributePropagationBuilder</a></h1>
<blockquote>
<p>The builder is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-elements-builders">@tmorin/ceb-elements-builders</a>.</p>
</blockquote>
<p>The builder handles the propagation of an attribute's values to embedded elements.
That means, each time the attribute is mutated, the mutation is propagated to selected child nodes.</p>
<h2 id="challenge-yourself-7"><a class="header" href="#challenge-yourself-7">Challenge yourself</a></h2>
<p>Will you be able to ...</p>
<ol>
<li>propagate the value of the attribute <code>value</code> to the property <code>placeholder</code> of the <code>input</code>?</li>
<li>propagate the value of the attribute <code>frozen</code> to the attribute <code>disabled</code> of the <code>input</code>?</li>
</ol>
<p class="codepen" data-height="400" data-theme-id="light" data-default-tab="js,result" data-slug-hash="qBmYKwe" data-editable="true" data-user="tmorin" style="height: 400px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/tmorin/pen/qBmYKwe">
  &lt;ceb/&gt; ~ challenge/AttributePropagationBuilder</a> by Thibault Morin (<a href="https://codepen.io/tmorin">@tmorin</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="propertydelegationbuilder"><a class="header" href="#propertydelegationbuilder">PropertyDelegationBuilder</a></h1>
<blockquote>
<p>The builder is bundled in the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-elements-builders">@tmorin/ceb-elements-builders</a>.</p>
</blockquote>
<p>The builder delegates the accesses of a property to an embedded element.</p>
<h2 id="challenge-yourself-8"><a class="header" href="#challenge-yourself-8">Challenge yourself</a></h2>
<p>Will you be able to ...</p>
<ol>
<li>delegate the property <code>value</code> to the attribute <code>placeholder</code> of the <code>input</code>?</li>
<li>delegate the property <code>frozen</code> to the property <code>disabled</code> of the <code>input</code>?</li>
</ol>
<p class="codepen" data-height="400" data-theme-id="light" data-default-tab="js,result" data-slug-hash="QWvrBNr" data-editable="true" data-user="tmorin" style="height: 400px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/tmorin/pen/QWvrBNr">
  &lt;ceb/&gt; ~ challenge/PropertyDelegationBuilder</a> by Thibault Morin (<a href="https://codepen.io/tmorin">@tmorin</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templating"><a class="header" href="#templating">Templating</a></h1>
<p><code>&lt;ceb/&gt;</code> provides a built-in solution for templating which relies on three main components.</p>
<p>The first component is the template engine.
Its purpose is to <em>patch</em> the DOM incrementally.
The implementation and the underlying API is similar to <a href="https://google.github.io/incremental-dom">incremental-dom</a>.
The main difference is the full support of Custom Elements, especially the handling of a <a href="templating/grey_dom.html">Grey DOM</a>, or <em>scope</em>.</p>
<blockquote>
<p>The engine is part of the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-templating-engine">@tmorin/ceb-templating-engine</a>.</p>
</blockquote>
<p>The second component is a user-friendly interface which operates the command.
Presently, the library provides an interface leveraging on the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">Tagged Templates</a>.
Its usage is cover in the <a href="templating/literal.html">Template literal</a> section.</p>
<blockquote>
<p>The user-friendly interface is part of the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-templating-literal">@tmorin/ceb-templating-literal</a>.</p>
</blockquote>
<p>Finally, the third component is a builder which enhances a method of the Custom Element: <a href="templating/../elements/TemplateBuilder.html">TemplateBuilder</a>.
So that, when the enhanced method is invoked, the Custom Element's content is dynamically updated.</p>
<blockquote>
<p>The builder is part of the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-templating-builder">@tmorin/ceb-templating-builder</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-light-grey-and-shadow-doms"><a class="header" href="#the-light-grey-and-shadow-doms">The Light, Grey and Shadow DOMs</a></h1>
<p>When a Custom Element is responsible for a part of its child nodes, the usage of <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">Shadow DOM</a> is welcoming.
Shadow DOM handles the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot">HTMLSlotElement</a> elements which can be used as placeholders.
However, Shadow DOM brings a level of isolation which is not always welcome.
Especially for the <em>shadowified</em> markup which relies on common stylesheets.</p>
<p>The built-in template engine provides a solution to handle Grey DOM.
The purpose is to keep the concept of <em>slot</em> coming from Shadow DOM but in the Light DOM.
Therefore, the DOM tree between the Custom Element node, and the <em>slot node</em> becomes a Grey DOM.</p>
<p>Basically, a Grey DOM can only be mutated from its Custom Element and, the Custom Element can only mutate its Grey DOM.
Moreover, like for the Shadow DOM, the Grey DOM handles kind of <code>&lt;slot&gt;</code> elements to manage the placeholders.
However, the Grey DOM is not isolated from the Light DOM context (javascript, styles ...).
For senior JS developers :), it is similar to the <a href="https://code.angularjs.org/1.8.2/docs/guide/directive#creating-a-directive-that-wraps-other-elements">transclude</a> concept implemented in <a href="https://angularjs.org">AngularJS</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-literal"><a class="header" href="#template-literal">Template literal</a></h1>
<blockquote>
<p>The template solution is part of the NPM package <a href="https://www.npmjs.com/package/@tmorin/ceb-templating-literal">@tmorin/ceb-templating-literal</a>.</p>
</blockquote>
<p>The built-in template solution provides an API to express templates based on <a href="templating/literal.html">Template literal</a>.
The API is the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">Tagged Templates</a> <code>html</code>.</p>
<h2 id="common-usages"><a class="header" href="#common-usages">Common usages</a></h2>
<h3 id="text"><a class="header" href="#text">Text</a></h3>
<p>Write the content <code>Hello, World!</code> in the <code>&lt;p&gt;</code> element:</p>
<pre><code class="language-typescript">import { Template } from &quot;@tmorin/ceb-templating-builder&quot;
import { html } from &quot;@tmorin/ceb-templating-literal&quot;

const name = &quot;World&quot;

const template: Template = html`&lt;p&gt;Hello, ${name}!&lt;/p&gt;`

template.render(document.body)
</code></pre>
<h3 id="attribute"><a class="header" href="#attribute">Attribute</a></h3>
<p>Set the value <code>foo</code> to the attribute <code>bar</code>:</p>
<pre><code class="language-typescript">import { Template } from &quot;@tmorin/ceb-templating-builder&quot;
import { html } from &quot;@tmorin/ceb-templating-literal&quot;

const foo = &quot;bar&quot;

const template: Template = html`&lt;input class=&quot;${foo}&quot; /&gt;`

template.render(document.body)
</code></pre>
<p>Set boolean values, the <code>checked</code> attribute won't be rendered because its value is <code>false</code>:</p>
<pre><code class="language-typescript">import { Template } from &quot;@tmorin/ceb-templating-builder&quot;
import { html } from &quot;@tmorin/ceb-templating-literal&quot;

const checked = false

const template: Template = html`&lt;input
  required
  disabled=&quot;&quot;
  checked=&quot;${checked}&quot; /&gt;`

template.render(document.body)
</code></pre>
<h3 id="property"><a class="header" href="#property">Property</a></h3>
<p>Set the value <code>foo</code> to the property <code>bar</code>:</p>
<pre><code class="language-typescript">import { Template } from &quot;@tmorin/ceb-templating-builder&quot;
import { html } from &quot;@tmorin/ceb-templating-literal&quot;

const value = &quot;Foo&quot;

const template: Template = html`&lt;input p:bar=&quot;${value}&quot; /&gt;`

template.render(document.body)
</code></pre>
<h3 id="prevent-extra-processing"><a class="header" href="#prevent-extra-processing">Prevent extra processing</a></h3>
<p>The special attribute <code>o:skip</code>, notifies the template engine that the children of the element should not be processed.</p>
<pre><code class="language-typescript">import { Template } from &quot;@tmorin/ceb-templating-builder&quot;
import { html } from &quot;@tmorin/ceb-templating-literal&quot;

const template: Template = html`&lt;div&gt;&lt;ul o:skip&gt;&lt;/ul&gt;&lt;/div&gt;`

template.render(document.body)
</code></pre>
<p>When rendering within a Shadow DOM, the usage of the element <code>&lt;slot&gt;</code> have the same effect: the children of the <code>slot</code> element won't be processed.</p>
<h3 id="optimize-patch-activities"><a class="header" href="#optimize-patch-activities">Optimize patch activities</a></h3>
<p>The special attribute <code>o:key</code>, notifies the template engine that the current node can be identified by a key.
The key can be of any types.</p>
<p>The feature should be used when rendering a dynamic list where the items can be added/removed/shift.
For each item, the <code>o:key</code> should be provided.
So that, the engine will be able to efficiently discover the related DOM nodes. </p>
<pre><code class="language-typescript">import { Template } from &quot;@tmorin/ceb-templating-builder&quot;
import { html } from &quot;@tmorin/ceb-templating-literal&quot;

const lis = [&quot;item A&quot;, &quot;item B&quot;].map(
  (item) =&gt; html`&lt;li o:key=&quot;${item}&quot;&gt;${item}&lt;/li&gt;`
)

const template: Template = html`&lt;div&gt;
  &lt;ul&gt;
    ${lis}
  &lt;/ul&gt;
&lt;/div&gt;`

template.render(document.body)
</code></pre>
<p>When rendering within a Shadow DOM, the usage of the element <code>&lt;slot&gt;</code> have the same effect: the children of the <code>slot</code> element won't be processed.</p>
<h2 id="grey-dom"><a class="header" href="#grey-dom">Grey DOM</a></h2>
<p>The special element <code>&lt;ceb-sot&gt;&lt;/ceb-slot&gt;</code> is the marker of the placeholder.</p>
<p>Given the following Custom Element with template expressed using the literal approach:</p>
<pre><code class="language-typescript">import { ElementBuilder } from &quot;@tmorin/ceb-elements-core&quot;
import { Template, TemplateBuilder } from &quot;@tmorin/ceb-templating-builder&quot;
import { html } from &quot;@tmorin/ceb-templating-literal&quot;

class HelloWorld extends HTMLElement {
  render(): Template {
    return html`&lt;p&gt;Hello, &lt;ceb-slot&gt;&lt;/ceb-slot&gt;!&lt;/p&gt;`
  }
}

ElementBuilder.get().builder(TemplateBuilder.get().grey()).register()
</code></pre>
<p>When the following statement is created and rendered:</p>
<pre><code class="language-html">&lt;hello-worlder&gt;John Doe&lt;/hello-worlder&gt;
</code></pre>
<p>Then the Light DOM becomes:</p>
<pre><code class="language-html">&lt;hello-worlder&gt;
  Hello, &lt;ceb-slot&gt;John Doe&lt;ceb-slot&gt;!
&lt;/hello-worlder&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Some examples demonstrate the usage of <code>&lt;ceb/&gt;</code> features:</p>
<ul>
<li><a href="examples/examples/todomvc/README.html">TodoMVC</a> : an implementation of the TodoMVC application</li>
<li><a href="examples/examples/ex-greeting/README.html">ex-greeting</a> : a simple Custom Element to display a greeting message</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todomvc"><a class="header" href="#todomvc">TodoMVC</a></h1>
<p>This example is an implementation of the <a href="https://todomvc.com">TodoMVC</a> application with <code>&lt;ceb/&gt;</code>.</p>
<iframe src="https://codesandbox.io/embed/ceb-example-todomvc-fzll0?fontsize=14&hidenavigation=1&theme=light&view=preview"
style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
title="&lt;ceb/&gt; ~ example - TodoMVC"
allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>The implementation embraces a kind of <a href="https://alistair.cockburn.us/hexagonal-architecture">Hexagonal Architecture</a> to provide a loose coupling integration between: the UI, the application logic (i.e. the model) and, the adapters (i.e. the persistence system ...).
The communication between both concerns the UI and the application logic is managed by a <a href="https://www.reactivemanifesto.org/glossary#Message-Driven">Message/Event Driven approach</a> which emphasizes the <a href="https://www.martinfowler.com/bliki/CQRS.html">CQRS pattern</a>.</p>
<h2 id="codebase"><a class="header" href="#codebase">Codebase</a></h2>
<p>The codebase is composed of four Bounded Contexts organized in modules.</p>
<h3 id="the-bounded-contexts"><a class="header" href="#the-bounded-contexts">The Bounded Contexts</a></h3>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>Todo</td><td>Manage the todos of the list.</td></tr>
<tr><td>Filter</td><td>Manage the filtering of the list.</td></tr>
<tr><td>App</td><td>Manage the application lifecycle.</td></tr>
<tr><td>User Interface</td><td>Manage the User Interface.</td></tr>
</tbody></table>
<p><img src="examples/todomvc/bounded_contexts.png" alt="The Bounded Contexts" /></p>
<h3 id="the-module-types"><a class="header" href="#the-module-types">The Module Types</a></h3>
<p>The modules are qualified by <em>types</em>.
The purpose of the <em>types</em> is to organize the source code according to the <a href="https://alistair.cockburn.us/hexagonal-architecture">Hexagonal Architecture</a>.</p>
<p>Each bounded context may have modules of the following types: <em>core</em>, <em>api</em>, <em>infra</em>, <em>ui</em> and <em>e2e</em>.</p>
<p>The <em>core</em> modules contain the implementation of the Bounded Context's functionalities.
They contain also the <em>ports</em> as defined by the Hexagonal Architecture.</p>
<p>The <em>api</em> modules provides resources to interact with the Bounded Context's functionalities.
They are mainly composed of message definitions (commands, events, queries and results) and other data structures.</p>
<p>The <em>infra</em> modules contain the implementations of <em>ports</em> defined in the <em>core</em> modules, i.e. <em>adapters</em> as defined by the Hexagonal Architecture.</p>
<p>The <em>ui</em> modules contain resources handling the interactions with humans.</p>
<p>Finally, the <em>e2e</em> (i.e. end-to-end ) modules contain test suites which can be used by <em>infra</em> modules to validate the implementation of <em>ports</em> coming from <em>core</em> modules.</p>
<h2 id="todo"><a class="header" href="#todo">Todo</a></h2>
<p>This bounded context manages the <em>todos</em> which composes the todo list.</p>
<p><img src="examples/todomvc/modules_todo.png" alt="The modules of Todo" /></p>
<h2 id="filter"><a class="header" href="#filter">Filter</a></h2>
<p>This bounded context manages the <em>filtering</em> of the todo list.</p>
<p><img src="examples/todomvc/modules_filter.png" alt="The modules of Filter" /></p>
<h2 id="app"><a class="header" href="#app">App</a></h2>
<p>This bounded context manages the <em>application</em> lifecycle.
The main purpose of the Bounded Context is to produce and publish the application state.</p>
<p><img src="examples/todomvc/modules_app.png" alt="The modules of App" /></p>
<h2 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h2>
<p>This bounded context manages the user interactions.
It is composed of only one module, <code>ui-elements</code>, which provide an implementation mainly based on Custom Elements.</p>
<p><img src="examples/todomvc/modules_ui_elements.png" alt="The modules of App" /></p>
<h2 id="collaboration-between-bounded-contexts"><a class="header" href="#collaboration-between-bounded-contexts">Collaboration between Bounded Contexts</a></h2>
<h3 id="addtodo"><a class="header" href="#addtodo">AddTodo</a></h3>
<p>The command AddTodo adds a new Todo to the todo list.
The command is triggered by the User Interface then once the causality chain is done, the Integration Event TodosUpdated is published.
Therefore, the UI can react.</p>
<p><img src="examples/todomvc/eventstorming_AddTodo.png" alt="The AddTodo flow" /></p>
<p>The flow is similar for the ChangeFilter command.</p>
<p><img src="examples/todomvc/eventstorming_ChangeFiler.png" alt="The ChangeFilter flow" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ex-greeting"><a class="header" href="#ex-greeting">ex-greeting</a></h1>
<p>This example demonstrates how to leverage on some builders and decorators to create a Custom Element which displays a greeting message.</p>
<p>The example is available on <a href="https://codepen.io/tmorin/pen/QWqKNwZ">codepen.io</a>!</p>
<h2 id="initiate-the-custom-element-class"><a class="header" href="#initiate-the-custom-element-class">Initiate the Custom Element class</a></h2>
<p>The Custom Element <code>ex-greeting</code> is a regular ES6 class which extends HTMLElement :</p>
<pre><code class="language-typescript">export class ExGreeting extends HTMLElement {}
</code></pre>
<h2 id="register-the-custom-element"><a class="header" href="#register-the-custom-element">Register the Custom Element</a></h2>
<p>To register <code>ex-greeting</code>, the decorator of <code>@ElementBuilder</code> is used:</p>
<pre><code class="language-typescript">import { ElementBuilder } from &quot;@tmorin/ceb-elements-core&quot;

@ElementBuilder.get().decorate()
export class ExGreeting extends HTMLElement {}
</code></pre>
<h2 id="initialize-the-shadow-dom"><a class="header" href="#initialize-the-shadow-dom">Initialize the Shadow DOM</a></h2>
<p>The Shadow DOM of <code>ex-greeting</code> is initialized with the decorator of <code>@ContentBuilder</code> :</p>
<pre><code class="language-typescript">import { ElementBuilder } from &quot;@tmorin/ceb-elements-core&quot;
import { ContentBuilder } from &quot;@tmorin/ceb-elements-builders&quot;

@ElementBuilder.get().decorate()
@ContentBuilder.get(`&lt;p&gt;Hello, &lt;span id=&quot;name&quot;&gt;&lt;/span&gt;!&lt;/p&gt;`)
  .shadow()
  .decorate()
export class ExGreeting extends HTMLElement {}
</code></pre>
<h2 id="capture-the-name"><a class="header" href="#capture-the-name">Capture the name</a></h2>
<p>The target of the greeting is captured with the field <code>name</code> using the decorator of <code>FieldBuilder</code> :</p>
<pre><code class="language-typescript">import { ElementBuilder } from &quot;@tmorin/ceb-elements-core&quot;
import { ContentBuilder, FieldBuilder } from &quot;@tmorin/ceb-elements-builders&quot;

@ElementBuilder.get().decorate()
@ContentBuilder.get(`&lt;p&gt;Hello, &lt;span id=&quot;name&quot;&gt;&lt;/span&gt;!&lt;/p&gt;`)
  .shadow()
  .decorate()
export class ExGreeting extends HTMLElement {
  @FieldBuilder.get().decorate()
  name: string = &quot;World&quot;
}
</code></pre>
<h2 id="update-the-shadow-dom-with-the-captured-name"><a class="header" href="#update-the-shadow-dom-with-the-captured-name">Update the Shadow DOM with the captured name</a></h2>
<p>Each time the field <code>name</code> mutates, the element selected by <code>span#name</code> has to be updated with the new value.
There are two ways to handle it with the built-in <code>&lt;ceb/&gt;</code> builders : the craft style and the propagation way.</p>
<h3 id="the-craft-style"><a class="header" href="#the-craft-style">The craft style</a></h3>
<p>The decorator of <code>ReferenceBuilder</code> retrieves the reference of the element <code>span#name</code>.</p>
<pre><code class="language-typescript">import { ElementBuilder } from &quot;@tmorin/ceb-elements-core&quot;
import {
  ContentBuilder,
  FieldBuilder,
  ReferenceBuilder,
} from &quot;@tmorin/ceb-elements-builders&quot;

@ElementBuilder.get().decorate()
@ContentBuilder.get(`&lt;p&gt;Hello, &lt;span id=&quot;name&quot;&gt;&lt;/span&gt;!&lt;/p&gt;`)
  .shadow()
  .decorate()
export class ExGreeting extends HTMLElement {
  @FieldBuilder.get().decorate()
  name: string = &quot;World&quot;

  @ReferenceBuilder.get().shadow().selector(&quot;span#name&quot;).decorate()
  span?: HTMLSpanElement
}
</code></pre>
<p>Finally, the decorator of <code>FieldBuilder</code> handles the mutation of the field <code>name</code>.</p>
<pre><code class="language-typescript">import { FieldListenerData } from &quot;@tmorin/ceb-elements-builders&quot;
import { ElementBuilder } from &quot;@tmorin/ceb-elements-core&quot;
import {
  ContentBuilder,
  FieldBuilder,
  ReferenceBuilder,
} from &quot;@tmorin/ceb-elements-builders&quot;

@ElementBuilder.get().decorate()
@ContentBuilder.get(`&lt;p&gt;Hello, &lt;span id=&quot;name&quot;&gt;&lt;/span&gt;!&lt;/p&gt;`)
  .shadow()
  .decorate()
export class ExGreeting extends HTMLElement {
  @FieldBuilder.get().decorate()
  name: string = &quot;World&quot;

  @ReferenceBuilder.get().shadow().selector(&quot;span#name&quot;).decorate()
  span?: HTMLSpanElement

  @FieldBuilder.get().decorate()
  private onName(data: FieldListenerData&lt;string&gt;) {
    if (this.span) {
      this.span.textContent = data.newVal
    }
  }
}
</code></pre>
<h3 id="the-propagation-way"><a class="header" href="#the-propagation-way">The propagation way</a></h3>
<p>Alternatively, the decorator of <code>AttributePropagationBuilder</code> can be used to automatically binds the mutation of the field <code>name</code> to the property <code>textContent</code> of the selected element <code>span#name</code> :</p>
<pre><code class="language-typescript">import { ElementBuilder } from &quot;@tmorin/ceb-elements-core&quot;
import { ContentBuilder, FieldBuilder, FieldListenerData, ReferenceBuilder } from &quot;@tmorin/ceb-elements-builders&quot;

@ElementBuilder.get&lt;ExGreeting&gt;().decorate()
@ContentBuilder.get(`&lt;p&gt;Hello, &lt;span id=&quot;name&quot;&gt;&lt;/span&gt;!&lt;/p&gt;`).shadow().decorate()
export class ExGreeting extends HTMLElement {
  @ReferenceBuilder.get().shadow().selector(&quot;span#name&quot;).decorate()
  span?: HTMLSpanElement

  @FieldBuilder.get().decorate()
  name = &quot;World&quot;

  @FieldBuilder.get().decorate()
  private onName(data: FieldListenerData&lt;string&gt;) {
    if (this.span) {
      this.span.textContent = data.newVal
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<h2 id="books"><a class="header" href="#books">Books</a></h2>
<ul>
<li>Domain-Driven Design: Tackling Complexity in the Heart of Software, by Eric Evans, 2004, <a href="https://www.dddcommunity.org/book/evans_2003">www.dddcommunity.org</a></li>
<li>Clean Architecture: A Craftsman's Guide to Software Structure and Design, by Robert C. Martin, 2018, <a href="https://www.pearson.com/us/higher-education/program/Martin-Clean-Architecture-A-Craftsman-s-Guide-to-Software-Structure-and-Design/PGM333762.html">www.pearson.com</a></li>
<li>Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions, by Gregor Hohpe and Bobby Woolf, 2004, <a href="https://www.enterpriseintegrationpatterns.com">www.enterpriseintegrationpatterns.com</a></li>
</ul>
<h2 id="articles"><a class="header" href="#articles">Articles</a></h2>
<ul>
<li><a href="https://www.martinfowler.com/bliki/CommandQuerySeparation.html">Command Query Separation</a></li>
<li><a href="https://martinfowler.com/bliki/CQRS.html">Command Query Responsibility Segregation</a></li>
<li><a href="https://alistair.cockburn.us/hexagonal-architecture">Hexagonal architecture, by Alistair Cockburn</a></li>
</ul>
<h2 id="specifications"><a class="header" href="#specifications">Specifications</a></h2>
<ul>
<li><a href="https://html.spec.whatwg.org/multipage/custom-elements.html">Custom Elements</a></li>
</ul>
<h2 id="libraries"><a class="header" href="#libraries">Libraries</a></h2>
<ul>
<li><a href="https://axoniq.io/product-overview/axon-framework">Axon Framework</a></li>
<li><a href="https://google.github.io/incremental-dom">incremental-dom</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
